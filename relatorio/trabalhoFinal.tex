\documentclass[12pt]{article}

\usepackage{sbc-template}
\usepackage{graphicx,url}
\usepackage[utf8]{inputenc}
\usepackage[portuguese]{babel}
\usepackage{float}
\usepackage{booktabs}
\usepackage{fancyvrb}
\usepackage[colorlinks=true, linkcolor=blue, urlcolor=blue]{hyperref}
     
\sloppy

\title{Implementação de heurísticas em \emph{Prolog} para o problema do contâiner}

\author{Bruno Barros Mello\inst{1} \\ Juliana Moura\inst{1} \\  Vitor
  Balestro\inst{1,2} }


\address{Instituto de Computação -- Universidade Federal Fluminense
  (UFF)\\
  Niterói -- RJ -- Brasil
\nextinstitute
  Instituto de Matemática e Estatística -- Universidade Federal Fluminense (UFF)\\
  Niterói -- RJ -- Brasil\\
%\nextinstitute
  %Departamento de Sistemas e Computação\\
  %Universidade Regional de Blumenal (FURB) -- Blumenau, SC -- Brazil
  \email{brunobarrosmello@id.uff.br, juliana$\_$moura@id.uff.br, vitorbalestro@id.uff.br}
}

\begin{document}

\maketitle

\begin{abstract} O problema do contâiner busca a melhor configuração de um conjunto de caixas em um contâiner. Este trabalho é dedicado a implementar soluções heurísticas em \emph{Prolog} para este problema.

\end{abstract}


\section{Introdução}

Neste trabalho, discutimos algumas implementações de heurísticas na linguagem \emph{Prolog} para resolver o \emph{problema do contâiner}. O enunciado do problema é o seguinte: dados um contâiner e um conjunto de caixas com dimensões especificadas (Largura x Altura x Profundidade), determinar a configuração de caixas no contâiner que maximize a quantidade de caixas empacotadas ou que minimize o volume restante no contâiner. Em nossas abordagens, adotamos o primeiro critério.

Nossa primeira estratégia é um algoritmo força bruta simples que não envolve ordenamento das caixas verifica todas as combinações possíveis de caixas no container, procurando a melhor solução. Entretanto, este algoritmo é ineficiente e não deve ser considerado uma solução válida, tendo sido feito apenas por fins didáticos. No nosso conjunto de entrada utilizado para testes o algortimos nem mesmo terminou de executar.

A segunda estratégia é um algoritmo guloso com a heurística de \emph{First Fit Decreasing}. Esta heurística ordena as caixas em ordem decrescente de volume como etapa de pré processamento, e em seguida tenta encaixar cada caixa em uma posição válida, considerando todas caixas que já foram inseridas. Se não conseguir encaixar uma caixa no container em nenhuma posição, pula esta caixa e continua na próxima.

Também implementamos uma variação da heurística \emph{First Fit Decreasing}, dessa vez com rotação de caixas. O princípio é o mesmo: ordena as caixas de forma decrescente pelo seu volume, percorre as caixas e tenta encaixar uma por uma, ignorando se não conseguir encaixar determinada caixa. A diferença é que nesta variação também testamos rotações para cada caixa, então se uma caixa (L x A x P) não couber no container, também tentamos suas rotações como (L x P x A), (A x P x L) etc.

Uma outra heurística implementada foi a \empth{Largest Area First Fit}. Nesta heurística, as caixas são ordenadas pela maior área da base. Para cada caixa, o algoritmo identifica as posições de encaixe disponíveis e escolhe aquela com a menor altura. Caixas que não podem ser encaixadas são ignoradas.

Todos os códigos implementados podem ser encontrados no repositório do trabalho: \url{https://github.com/vitorbalestro/TrabalhoProlog}. Uma boa referência para o problema do contâiner é \cite{ngoi}.

\section{Algoritmo guloso simples}

Neste algoritmo, as caixas devem ser consideradas em uma lista não-ordenada. As caixas são construídas como predicados da forma
\begin{verbatim} caixa(ID, C, L, A),
\end{verbatim}
e a lista é obtida através do método \emph{findall}. O contâiner é declarado pelo predicado
\begin{verbatim} container(C, L, A).
\end{verbatim}

O estado inicial do problema é a declaração do contâiner e das caixas. O algoritmo constrói a lista de caixas e percorre esta lista verificando se cada caixa pode ser incluída no contâiner. A regra para isto é simples: o algoritmo guarda a soma das dimensões de todas as caixas anteriormente adicionadas, e compara as dimensões da caixa atual com os valores ``restantes" no contâiner. Se a caixa atual não puder ser inserida segundo este critério, esta caixa é ignorada e a próxima caixa da lista é lida.

Note que esta estratégia pode ser muito ineficiente. Se uma das dimensões for ``completada", então o algoritmo não aceitará nenhuma caixa adicional, ainda que sobre muito espaço no contâiner. Além disso, esta implementação não considera rotações das caixas.

O estado final do algoritmo é a lista das caixas que foram incluídas no contâiner. No repositório do trabalho, este algoritmo está no arquivo greedy.pl.

Em todos algoritmos, declaramos o contâiner como um predicado
\begin{verbatim} container(W, H, D).
\end{verbatim}
e as caixas com predicados
\begin{verbatim} box(W, H, D).
\end{verbatim}
O ponto de entrada dos algoritmos é o predicado
\begin{verbatim} solve.
\end{verbatim}

\section{\emph{Algoritmo força bruta}}

Neste algoritmo, buscamos todas as combinações possíveis para unificação do predicado \empth{pack}, e em seguida percorremos os resultados para encontrar a melhor solução. O predicado pack procura uma posição possível para a caixa com auxílio do método \empth{between}, verifica se esta posição é válida e empacota esta caixa se for possível. Caso não seja possível, ignora a caixa e pula para a próxima.

\section{\emph{First Fit Decreasing}}

Neste algoritmo, primeiro ordenamos todas as caixas pelo seu volume, de forma decrescente. A lista ordenada de caixas é percorrida, e a cada etapa o algoritmo tenta encontrar uma posição para a caixa atual usando o método \emph{between}. Se não encontrar nenhuma posição válida, pula e vai para a próxima caixa. No fim, temos um corte, para garantir que consideremos apenas a primeira solução unificada.

\section{FFD com rotações}

Este algoritmo é bem semelhante ao anterior, exceto pelo fato de também considerar rotações das caixas. Assim, o algoritmo verifica as posições possíveis para uma caixa, e se não for possível empacotar desta forma também considera as variações de rotações para esta caixa. Uma caixa é ignorada apenas se nenhuma rotação couber no empacotamento.

\section{\emph{Largest Area First Fit}}

O estado inicial do problema é o mesmo da heurística FFD: um contâiner tri-dimensional e uma coleção de caixas tri-dimensionais. Primeiro, as caixas são ordenadas por área da base decrescente. Então, o algoritmo percorre esta lista ordenada tentando empacotar cada caixa. Para isto, o algoritmo testa todas as posições possíveis de empacotamento, e seleciona aquela que tem a menor altura. Esta heurística foi inspirada em \cite{gurbuz}.

\section{Extra: visualização da solução com Minecraft}

Uma dificuldade que o grupo teve com este trabalho foi conseguir visualizar facilmente a solução gerada pelos algoritmos, para validar que está correta. Para isso, uma vez que a solução foi gerada adicionamos uma seção de impressão de comandos \textit{fill} do jogo Minecraft para conseguir preencher uma região com blocos de diferentes cores de acordo com a solução gerada pelo algoritmo. Uma demonstração desta visualização pode ser encontrada \href{https://www.youtube.com/watch?v=qInZZb9y1dQ}{aqui}.

Esta visualização foi utilizada em todos os métodos, mas para não poluir os arquivos de solução com código repetido de coisas extras, manteremos o código desta parte apenas no arquivo \textit{ffd$\_$with$\_$rotation.pl}. Note que o sistema de coordenadas do jogo utiliza o eixo Z invertido, então coordenadas $(X, Y, Z)$ viram $(X, Y, -Z)$ no jogo.

\section{Resultados e Discussão}

Executamos o método guloso e o método LAFF para um contâiner de 50 x 50 x 50 e 30 caixas. Conforme esperado, o método guloso teve uma performance muito ruim: apenas 5 caixas foram empacotadas. O método LAFF, por outro lado, conseguiu empacotar todas as caixas (solução ótima, sob nosso ponto de vista de quantidade de caixas empacotadas). Ao reduzir o contâiner para 20 x 20 x 20, o LAFF empacotou 13 caixas, e o algoritmo guloso empacotou apenas 3. O tempo de execução para o método guloso é desprezível. O tempo de execução do método LAFF nos dois testes ficou na ordem de segundos.

O método FFD apresentou menor eficiência do que o método LAFF. A tentativa de execução deste método para 30 caixas resultou em estouro de pilha. Para um estado inicial de 15 caixas em um contâiner de 20 x 20 x 20, o método FFD com rotações empacotou 13 caixas (assim como o LAFF). Entretanto, o tempo de execução está na ordem dos minutos.

A razão para a menor eficiência do FFD possivelmente estã no fato de que esta heurística considera \textbf{todas} as posições possíveis de empacotamento e, portanto, cria (abstratamente) uma árvore de possíveis empacotamentos cuja quantidade de nós é exponencial no tamanho do container. Depois, o algoritmo seleciona a melhor delas. O método LAFF, por outro lado, considera uma escolha gulosa: dadas as posições possíveis (de cada etapa), apenas uma delas é selecionada segundo um critério (especificamente, a menor altura da posição).

Em resumo, os testes executados indicam que a heurística LAFF é mais eficiente e não tem perda significativa de qualidade em relação à heurística FFD.

\begin{thebibliography}{99}

	\bibitem{gurbuz} M. G\"{u}rb\"{u}z, S. Akyokus, I. Emiroglu, A. G\"{u}ran: An Efficient Algorithm for 3D Rectangular Box Packing. \emph{Applied Automatic Systems Proceedings of Selected AAS}. Ohrid, 26--29.09.2009. Published by `Society of ETAI of Republic of Macedonia, Skopje, 2009.

	\bibitem{ngoi} B. K. A. Ngoi, M. L. Tay, E. S. Chua: Applying spatial representation techniques to the container packing problem. \emph{Int. J. Prod. Res.} \textbf{32} (1), pp. 111--123, 1994.

\end{thebibliography}

\end{document}
